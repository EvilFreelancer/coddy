---
description: Workflow rules for documentation, bug fixes, and new features
globs: docs/**/*, **/*.py, tests/**/*.py
alwaysApply: true
---

# Workflow Rules for Documentation, Bugs, and New Features

## Branch and Commit Conventions (When Working on an Issue)

When the agent works on an issue (creates a branch and makes commits), follow these conventions:

### Default Branch and New Issues

- **New branch from default**: When a new issue arrives and work starts, **always create the new branch from the default branch** (e.g. `main` or `master`). Before creating the branch: checkout default branch, pull latest, then create and switch to the new branch. This keeps each issue branch based on current default, not on a previous issue branch.
- **Switch back after PR**: After completing edits, committing, pushing, and opening the PR, **switch back to the default branch** (e.g. `git checkout main`). Coddy must not stay on the feature branch - so the next issue or run starts from default.

### Branch Name
- Format: `{issue_number}-short-description-1-3-words`
- Short description: 1-3 words from the issue title, in **English**, **lowercase**, words separated by **dashes**
- Example: for issue #42 "Add user login form" use branch `42-add-user-login`

### Commit Messages
- Format: `#{issue_number} Description of what was done`
- Example: `#42 Add login form and validation`
- The bot may make **multiple commits** during work (each Cursor edit session = one commit); each commit uses this format

### Full Task Flow (Code Agent - When Working on an Issue)

1. Read and execute the task from `.coddy/task-{issue_number}.md` (issue title, description, comments)
2. Implement the task following project rules (.cursor/rules, docs)
3. **Final verification loop** (repeat until all pass):
   - Run **full test suite**: `pytest tests/ -v`
   - Run **pre-commit**: `pre-commit run -a`, fix any errors
   - If there are failures: fix the issues, **commit** with message `#{issue_number} <description of fix>`, then repeat from step 3
4. **Last mandatory step**: Write the description of what was done to `.coddy/pr-{issue_number}.md` (PR report). Include: what was done, how to test, reference to issue, and a line that closes the issue (e.g. `Closes #42` or `Fixes #42` so the issue is auto-closed when the PR is merged). Use markdown; do not write code in this file. This step must be done **after** all implementation and verification (linter, tests) are complete. The bot uses this file as the PR description when creating the pull request.
5. Only then consider the work session complete (bot will commit/push and open PR).
6. **After PR is created**: Switch back to the default branch (e.g. `git checkout main`). Do not leave the repository on the feature branch so that the next issue or run starts from default.

**Mandatory**: When work on an issue is finished (PR created or session ended), always switch back to the default branch. The repo must not remain on the feature branch.

See @docs/system-specification.md for the full issue processing workflow.

### After Completing Edits (Final Verification Loop)

1. Run **full test suite**: `pytest tests/ -v`
2. If there are failures: fix the issues, **commit** with message `#{issue_number} <description of fix>`, then repeat from step 1 until all checks pass
3. Run **pre-commit**: `pre-commit run -a`, fix any errors
4. **Last mandatory step**: Write the PR description (what was done, how to test, and a line like `Closes #42` so the issue is closed when the PR is merged) to `.coddy/pr-{issue_number}.md` - the code agent must do this as the final step of every task
5. Only then consider the work session complete (e.g. open PR or report).
6. **After PR is created**: Switch back to the default branch so the next issue or run starts from default (do not leave the repo on the feature branch).

**On task completion**: Always run `git checkout main` (or the project default branch) when work on the task is done. Never leave the repository on the feature branch.

### Before Commit

Before making a commit, **always** run `pre-commit run -a` and fix any reported errors. This runs all pre-commit hooks (lint, format, etc.) on the whole repository and ensures the code meets project standards before commit.

## Documentation

### Documentation Location
- **All documentation** must be in `docs/` folder
- **API documentation** must be in `docs/api.md` (if applicable)
- **Configuration examples** must be in `docs/configuration.md`
- **Architecture documentation** must be in `docs/architecture.md`

### Documentation Standards
- Write documentation in **English**
- Use Markdown format
- Include code examples where appropriate
- Keep documentation up to date with code changes

## New Features (TDD Approach)

### Mandatory Workflow for New Features

**CRITICALLY IMPORTANT**: When user asks to implement a new feature (using words "фича", "feature", "новая функция", "добавить", "implement", "add"), **always** apply TDD approach and follow this strict workflow:

**Do not skip any step!** Always follow order: write test (red) → verify test fails → implement feature → test (green) → run all tests → run linter → report.

### Step-by-step Process for New Features

1. **Write test first**
   - Create test in corresponding file `tests/test_*.py`
   - Test must **fail** (red) because feature doesn't exist yet
   - Test must clearly describe expected behavior
   - Make sure test actually fails for the right reason

2. **Verify test fails**
   - Run new test: `pytest tests/test_*.py::test_name -v`
   - Test must **fail** (red) - this confirms test is correct
   - If test passes unexpectedly, review test logic

3. **Implement feature**
   - Write code that implements new feature
   - Follow rules from @code-style.mdc and @architecture.mdc
   - Use @implementation-order.mdc if adding new classes
   - Start from lower architecture layers

4. **Verify feature works**
   - Run new test - it must **pass** (green)
   - Make sure feature works as expected

5. **Run all tests**
   - Execute full test suite: `pytest tests/ -v`
   - Make sure **all tests are green**
   - If there are failing tests - fix them before proceeding

6. **Run linter**
   - Execute linter: `ruff check .`
   - Execute formatter: `ruff format .`
   - Fix all linting errors
   - Make sure linter passes completely

7. **Write report**
   - Brief report of work done
   - What feature was implemented
   - Which tests were added/changed
   - Test run results
   - Linter results

### Report Structure Example for New Features

```markdown
## Feature: [brief description]

### Implementation
1. Added test `test_new_feature` in `tests/test_module.py` (initially red)
2. Implemented `new_method` in `src/coddy/module.py`
3. Ran new test - passed (green)
4. Ran all tests - all green (X passed)
5. Ran linter - all checks passed

### Changed Files
- `src/coddy/module.py` - added new_method implementation
- `tests/test_module.py` - added test_new_feature test
```

## Bug Fixes (TDD Approach)

### Mandatory Workflow for Bug Fixes

**CRITICALLY IMPORTANT**: When user asks to fix a bug (using words "баг", "bug", "ошибка", "error", "исправить", "fix"), **always** apply TDD approach and follow this prompt:

```
<bug description>

First write a test reproducing this bug, make sure the error actually exists, then write code fixing the error and run the test, then when the new test works run all tests and if they are all green write a brief report of the work done.
```

**Do not skip any step!** Always follow order: test (red) → fix → test (green) → all tests → run linter → report.

### Step-by-step Process

1. **Write test reproducing bug**
   - Create test in corresponding file `tests/test_*.py`
   - Test must **fail** (red) and reproduce bug
   - Make sure error actually exists

2. **Fix code**
   - Write code that fixes bug
   - Follow rules from @code-style.mdc and @architecture.mdc

3. **Verify fix**
   - Run new test - it must **pass** (green)
   - Make sure bug is fixed

4. **Run all tests**
   - Execute full run: `pytest tests/ -v`
   - Make sure **all tests are green**
   - If there are failing tests - fix them

5. **Run linter**
   - Execute linter: `ruff check .`
   - Execute formatter: `ruff format .`
   - Fix all linting errors
   - Make sure linter passes completely

6. **Write report**
   - Brief report of work done
   - What was fixed
   - Which tests were added/changed
   - Test run results
   - Linter results

### Report Structure Example for Bug Fixes

```markdown
## Bug Fix: [brief description]

### Problem
[Bug description]

### Solution
1. Added test `test_bug_reproduction` in `tests/test_module.py` (initially red)
2. Fixed method `method_name` in `src/coddy/module.py`
3. Ran new test - passed (green)
4. Ran all tests - all green (X passed)
5. Ran linter - all checks passed

### Changed Files
- `src/coddy/module.py` - fixed processing logic
- `tests/test_module.py` - added test for bug
```

## Final Verification Before Reporting

**MANDATORY**: Before writing final report for any work (bug fix or new feature), **always** complete these steps:

1. **Run pre-commit**: `pre-commit run -a`
   - Fix any errors reported by hooks
   - All hooks must pass before proceeding

2. **Run all tests**: `pytest tests/ -v`
   - All tests must pass (green)
   - No test failures allowed

3. **Run linter**: `ruff check .`
   - All linting checks must pass
   - Fix all errors and warnings

4. **Run formatter**: `ruff format .`
   - Code must be properly formatted
   - Fix all formatting issues

5. **Only then write report**
   - Report must include test results
   - Report must include linter results
   - Report must confirm all checks passed

## References

@testing.mdc
@code-style.mdc
@docs/system-specification.md
