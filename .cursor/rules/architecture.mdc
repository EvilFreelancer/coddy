---
description: Architectural rules and boundaries for Coddy Bot
globs: coddy/**/*.py, tests/**/*.py
alwaysApply: true
---

# Architectural Rules

## General Architecture

The project uses **modular architecture with clear separation of concerns**. Code is organized into **observer** (events, state, queue), **worker** (ralph loop, agents), and **utils** (shared helpers). See `docs/architecture.md` for the full layout.

## Package Layout

### Observer (`coddy/observer/`)

Daemon-side: events, state, queue, planning. Does not run the AI agent.

- **adapters/** - Git platform adapters (base, github)
- **models/** - Pydantic models (Issue, Comment, PR, ReviewComment)
- **issues/** - Issue storage (issue_file, issue_store, issue_state)
- **planner.py** - Plan and user confirmation flow
- **pr/** - Review handler (process PR review comments)
- **webhook/** - Webhook server and handlers
- **run.py** - Observer entry (webhook server; plan on assignment)

**Dependencies**: config, standard lib, third-party only (no worker/utils)

### Worker (`coddy/worker/`)

Runs the development loop and uses the AI agent.

- **agents/** - AI agent interface (base, cursor_cli_agent)
- **task_yaml.py** - Task and PR report YAML paths and helpers
- **ralph_loop.py** - Ralph loop (sufficiency, branch, agent loop)
- **run.py** - Worker entry (dry-run stub: read issues, write empty PR YAML)

**Dependencies**: observer (store, models), utils

### Utils (`coddy/utils/`)

Shared utilities; no business logic.

- **branch.py** - Branch name sanitization, validation
- **issue_to_markdown.py** - IssueFile to markdown for agent
- **git_runner.py** - Git operations (pull, checkout, fetch)

**Dependencies**: observer only for types where needed

### Application entry (`coddy/`)

- **main.py** - CLI (observer | worker), config load, dispatch
- **config.py** - Configuration
- **daemon.py**, **worker.py** - Thin wrappers for `python -m coddy.daemon` (-> observer.run) / `python -m coddy.worker`

## Module Rules

### Platform Adapters (`observer/adapters/`)

- Must implement abstract base class from `base.py`
- Must handle platform-specific API differences
- Must provide unified interface for upper layers
- Should handle rate limiting and retries

### AI Agents (`worker/agents/`)

- Must implement abstract base class from `base.py`
- Must handle agent-specific command execution
- Must parse agent output into standardized format
- Should handle timeouts and errors gracefully

### Observer components (planner, webhook, pr)

- Should use adapters for API calls, not direct HTTP
- Should contain event/state logic only; agent runs in worker
- Should be testable in isolation with mocks

### Webhook Server (`observer/webhook/`)

- Must verify webhook signatures
- Must handle different event types
- Should route events to appropriate handlers
- Should log all events

## Design Principles

1. **One class at a time**: When implementing new functionality, create one class at a time, starting from lower layers
2. **Minimal dependencies**: Observer does not depend on worker; worker depends on observer and utils
3. **Factory pattern**: Use factory helpers for agents (e.g. `make_cursor_cli_agent(config)`)
4. **Strategy pattern**: Use strategy pattern for different platform/agent implementations
5. **Type hints**: Use type hints for all functions and methods
6. **Abstract interfaces**: Define abstract base classes for extensibility
7. **Error handling**: Use specific exceptions, not generic Exception
8. **Configuration**: Load configuration from environment variables and config files

## Forbidden

- Upper layers depending on lower layers in wrong order
- Direct API calls from observer/worker (must use adapters)
- Platform-specific code outside `observer/adapters`
- Agent-specific code outside `worker/agents`
- Business logic in webhook handlers (delegate to planner/queue)
- Hardcoded configuration values

## Allowed

- Observer using only adapters, issues, queue, models
- Worker using observer (adapters, queue, models) and utils
- Abstract base classes for interfaces
- Factory helpers for creating agents
- Configuration through environment variables
- Dependency injection for testability

## References

@README.md
@docs/architecture.md
@docs/system-specification.md
